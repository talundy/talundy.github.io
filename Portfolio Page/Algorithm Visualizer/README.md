# Algorithm Visualizer

A lightweight, professional algorithm visualizer that demonstrates merge sort with clean, efficient code.

## 🚀 Features

- **Interactive Visualization**: Step-by-step merge sort execution
- **Professional Controls**: Play, pause, step forward/backward, reset
- **Keyboard Shortcuts**: Space (play/pause), ←/→ (step), R (reset)
- **Real-time Metrics**: Track comparisons, swaps, and progress
- **Multiple Array Patterns**: Random, sorted, reversed, nearly sorted
- **Responsive Design**: Works on desktop and mobile
- **No Dependencies**: Pure HTML, CSS, and JavaScript

## 🎯 How to Use

1. **Open** `simple-visualizer.html` in any modern browser
2. **Adjust** array size (5-50 elements)
3. **Select** array pattern (random, sorted, reversed, nearly sorted)
4. **Generate** new arrays and watch the algorithm work
5. **Control** playback with buttons or keyboard shortcuts

## 🏗️ Engineering Highlights

- **Clean Architecture**: Well-organized JavaScript classes
- **Modern ES6+**: Classes, arrow functions, destructuring
- **Performance**: Efficient rendering with requestAnimationFrame
- **Accessibility**: Keyboard navigation and semantic HTML
- **Responsive**: Mobile-first CSS design
- **Maintainable**: Single file, easy to understand and modify

## 📱 Browser Support

- Chrome 60+
- Firefox 55+
- Safari 12+
- Edge 79+

## 🚀 Deployment

Simply upload `simple-visualizer.html` to any web server or GitHub Pages. No build process required!

## 💻 Code Structure

```javascript
class SimpleAlgorithmVisualizer {
  // Core functionality
  generateArray()      // Create new arrays
  generateOperations() // Generate algorithm steps
  render()            // Update visualization
  animate()           // Handle playback
}
```

## 🎨 Customization

The visualizer is easily customizable:
- Colors in CSS variables
- Animation speeds
- Array size limits
- Additional algorithms

## 📊 Performance

- **File Size**: ~24KB (vs 107MB with dependencies!)
- **Load Time**: Instant (no JavaScript bundles)
- **Animation**: Smooth 60 FPS
- **Memory**: Efficient operation tracking

## 🎉 Why This Approach?

This simple version demonstrates:
- **Engineering judgment**: Knowing when to keep things simple
- **Code quality**: Clean, maintainable code without over-engineering
- **User experience**: Fast loading, responsive design
- **Deployment**: Easy to deploy and maintain

Sometimes the best engineering solution is the simplest one that gets the job done! 🚀 
